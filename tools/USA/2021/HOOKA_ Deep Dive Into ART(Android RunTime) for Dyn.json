{
  "Tool Name": "HOOKA: Deep Dive Into ART(Android Runtime) For Dynamic Binary Analysis",
  "Speakers": [
    "Seong Hyun Song"
  ],
  "Tracks": [
    "Track: Android",
    "iOS and Mobile Hacking"
  ],
  "Event": "BH-ARSENAL",
  "Github URL": "https://gist.github.com/standardgalactic/7f03809c56f4b098b95a50ada32cd02c",
  "Description": "Google has changed Android runtime drastically each time a new version of Android is released to optimize the performance, storage usage, and system updates of apps. The profiling data has started to be generated in the recent version of Android 10, based on the user's behavior in ART (Android Runtime). Based on the profiling data, the byte code is optimized (Profile-Guided optimization and Cloud Profile optimization) by the compiler (AOT/JIT). ART also interprets and executes different types of code (byte code, oat code, and jit code) generated by the compiler. Such complexity in the structure and the operation method makes ART difficult to understand correctly. However, since all the code of the app is interpreted and executed through ART, if the attacker understands how ART works, it is possible to steal all the information necessary to analyze the app. Therefore, in this paper, we analyze the flow and structure of how the app code is interpreted and executed by objects existing in Android 10 ART. Then, by modifying the ART based on the analysis results, we develop a framework that can steal the information in real-time, such as smali code, interface, parameters, return value, fields, and stack trace of a method that is executed dynamically. In addition, we present an easy technique to effectively analyze the app without accessing the execution code by using tools such as decompiler or disassembler.\n\nIn existing debugger or hooking frameworks that dynamically analyze the apps in the Android environment, it is forcibly attached to the target analysis process, and the code is injected to read or analyze the code in the memory area while the execution code is loaded in memory. Since these methods are blocked by RASP (Runtime Application Self Protection), it takes a lot of time for attackers or analysts to bypass it and analyze the app.\n\nThe method proposed in this paper, on the other hand, analyzes the app by modifying the ART (Android Runtime) itself which is responsible for loading and executing the app's execution code in memory in Android. Even if any Anti-Hooking and Anti-Debugging techniques are applied to the app, all the codes are eventually executed through ART. This allows us to dump the dynamically executed code as smali code without being detected by RASP. In addition, all runtime information (such as stack trace, args, return value, etc.) of running functions can be captured and used for the analysis.\n\nThis technique is basically to redevelop ART in Android. Most similar methods that change the system modules in Android build the Android OS in debug mode. This makes such approach with the system modification more easily detectable by RASP.\nHowever, the method proposed in this presentation bypasses AVB (Android Verified Boot) and SafetyNet in the kernel, and then patch only the ART module from Stock Rom released by Google. Therefore, I present an effective method to easily analyze apps without being detected by RASP.",
  "Year": "2021",
  "Location": "USA"
}